
\documentclass{article}

\usepackage[utf8]{inputenc}

%Librerias Matematicas
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage[table]{xcolor}% http://ctan.org/pkg/xcolor
%Algorithms
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}


\usepackage{soul}%To highligh
\usepackage{fancyhdr}
\usepackage[a4paper]{geometry}
\usepackage{parskip}
\usepackage{changepage}
\usepackage{lipsum}
\usepackage{tikz}
\usepackage{tikzpagenodes}

\usepackage{graphicx}
\usepackage{wrapfig}

\usepackage{adjustbox}
\usepackage{multirow}


\pagestyle{plain}

%Paper Margins and size
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=30mm,
 top=20mm,
 right=30mm,
 bottom=20mm
 }

%Page Numeration
\pagestyle{plain}
\thispagestyle{empty}
\clearpage\pagestyle{plain}

%Interline 1.5 (of Word)
\linespread{1.25}

%Ident between 0.5 - 1.25max
\setlength{\parindent}{15pt}

%Math Theorem style
\newtheorem{theorem}{Teorema}
\newtheorem{corollary}{Corolario}[theorem]
\newtheorem{lemma}{Lemma}
\newtheorem*{remark}{Nota}
\theoremstyle{definition}
\newtheorem{definition}{Definición}[section]
\newenvironment{Proof}[1][Proof]
  {\proof[#1]\leftskip=1cm}
  {\endproof}

%Algorithm and PseudoCode
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother 


\begin{document}

\begin{titlepage}
	\begin{center}
	    \includegraphics[scale = 0.5]{LogoIngenieriaR.jpg}\\[1.0 cm]
	\end{center}
	
    \vspace*{150pt}
    \centering
    {\Huge
     \textbf{DEUSZUM}
    }
    
	\vspace*{200pt}
	
	
	\begin{minipage}{2in}
		\begin{tabular}{l}
			Terres Escudero, Erik B.    \\
			Zarate Jayo, Gorka   \\
			Zugazaga Alonso, Aritz  \\
			Acha Aristegui, Amaia  \\
			Gago López,Leire  \\
			San Millan Langa, Lander 
		\end{tabular}
	\end{minipage}
	\hfill
	\begin{minipage}{3in}
	\begin{flushright}
	\Large Curso 2019/2020 \\
		\Huge Ing. Informatica\\
		\LARGE Programacion III
	\end{flushright}
		
	\end{minipage}


    
	
\end{titlepage}

\tableofcontents

\clearpage

\section{INTRODUCCIÓN}

DeusZum es una aplicación de gestión de dinero online para la gestión de pagos, proyectos o costes grupales. DeusZum ofrece un sistema seguro de transferencias de forma que el cliente no tenga que preocuparse de que este pasando con su dinero en todo momento.

DeusZum estará implementado en un servidor y daría servicio a los usuarios a través de un programa en Windows y una aplicación en Android. Cada una de ellas implementada para conectarse a un servidor central, en el cual se almacenarán los datos, procesarán las peticiones y se garantizará la seguridad de la información.

El servicio que ofrece DeusZum está dividido en diferentes sectores, algunos puramente económicos y otros de análisis de la conducta o de las transacciones. El servidor ejecutara todas las peticiones de los usuarios y devolverá la información que se haya solicitado. Toda la información mientras se enviá se encontrara encriptada para la seguridad del usuario.

\section{FORMA DE TRABAJO}


\subsection{Division del trabajo}

Para la realización del proyecto, hemos optado por la división del trabajo en grupos con temáticas separadas. Los dos grupos tendrán que trabajar en una categoría central entre IA y Seguridad, y, trabajar en una parte de la implementación y algoritmia. Las categorías y subcategorías serian las siguientes:

\begin{center}
\begin{tabular}{|c|c|c|}
	\hline	
	\cellcolor{cyan!12} Implementacion & \cellcolor{cyan!12}Uso de datos & \cellcolor{cyan!12}Seguridad \\ \hline
	Servidor & Data Analysis & Database \\
	Windows & IA & Criptografia \\
	Android & Big Data & Proteccion \\
	\hline
	
\end{tabular}
\end{center}



Cada uno de los grupos tendra un conjunto de tareas las cuales se diviran en \textit{tareas principales} y \textit{tareas secundarias}. Las tareas principales son aquellas a las que se les daran prioridad y buscamos que esten terminadas a la hora de terminar el proyecto. Las tareas secundarias son aquellas que no tienen tanta importancia y que se empezaran una vez se vallan acabando las tareas principales.

A su vez, las tareas estaran numeradas segun importancia, dificultad y tiempo de trabajo con el fin de poder establecer un orden de prioridad para que su progreso haga que el proceso de construccion del proyecto sea relativamente optimo y de forma que su estructura no se vea afectada por software anterior.

Por ultimo, hay un sector no especializado que trata los temas de algoritmia sobre como handlear la forma de minimizar el total de pagos que hay realizar en forma de peticiones. Este algoritmo estara pensado en forma de algoritmo greedy al tener complejidad $O(n)$, pero en caso de que consigamos un algoritmo que no dependa de combinatorial algorithms o complejidades exponenciales para encontrar el minimo numero de pagos, tal vez aniadamos la opcion. Por ahora no sabemos como de rentable resultaria este algoritmo, ni tampoco sabemos ninguna upperbound del numero de movmientos que sea inferior a $n$ aproximadamente. Esto se mostrara en la bibliografia final o en la documentacion sobre el software.

El apartado de algoritmia se dividira segun convenga, aunque se mostrara dentro de la documentacion quien ha hecho que tareas y como ha resuelto los problemas.
\subsection{Error Handling}

Para evitar errores que afecten al codigo a nivel global, hemos optado por utilizar github y hacer que cada miembro del grupo tenga su propia cuenta. Los errores, comentarios y todo se enviarian a traves de github excepto la informacion mas urgente que se enviaria a traves de un grupo de whatsapp o telegram/discord en si defecto.

\subsection{Preparacion del temario}

Para la preparacion del temario que queremos trabajar en el trabajo hemos optado por utilizar un conjunto de libros que consideramos basicos para las personas que no tienen mucha experiencia y utiles/importantes para las personas que tengan un cierto control en ciertos aspectos. Esta lista de libros se encontrara en el apendice de este documento categorizada.

\section{PLANIFICACION}

\subsection{8 de octubre	E1. Propuesta de proyecto y planificación }

\begin{itemize}
\item Server \begin{enumerate}
\item Conseguir conectar un servidor SQL a el servidor.
\item Hacer que el servidor lea archivos properties.
\item Preparar la forma en la que se organizarán las carpetas en el servidor
\end{enumerate}
\item Desktop \begin{enumerate}
\item Crear la ventana junto con sus componentes.
\item Crear el metodo para enviar sockets.
\end{enumerate}
\item Android \begin{enumerate}
\item Leer un poco sobre Android
\item Crear una aplicación basica
\end{enumerate}
\item Database \begin{enumerate}
\item Crear la estructura de la base de datos.
\item Crear una base de datos en servidor local
\end{enumerate}
\item Seguridad \begin{enumerate}
\item Haber leido un mínimo sobre RSA, Blowfish, MD5, SHA512, Cesar... 
\item Plantear los métodos de encriptación que se usarán para cada tarea dentro del servidor.
\item Preparar la forma en la que se organizarán las carpetas en el servidor
\end{enumerate}
\item IA \begin{enumerate}
\item Plantear que metodos usaremos en el proceso
\item Plantear que tipo de bots queremos usar
\item Preparar la forma en la que se organizarán las carpetas en el servidor
\end{enumerate}
\item Miscelánea \begin{enumerate}
\item Entender como funciona la documentación del proyecto.
\item Entender como funciona el sistema de comandos del servidor.
\item Organizar el repositorio.
\item Estudiar la posibilidad de cambiar la documentación a una wiki.
\end{enumerate}

\end{itemize}

\subsection{29 de octubre	E2. Fase I del proyecto}

\begin{itemize}
\item Server \begin{enumerate}
\item Estructurar bien el servidor.
\item Todos los mensajes de los sockets deberán ir encriptados.
\item 
\end{enumerate}
\item Desktop \begin{enumerate}
\item Cliente funcional para enviar sockers
\item Cliente visualmente no horrible
\end{enumerate}
\item Android \begin{enumerate}
\item Cliente funcional para enviar sockers
\item Cliente visualmente no horrible
\end{enumerate}
\item Database \begin{enumerate}
\item La base de datos debe estar creada y con algunos datos de ejemplo
\end{enumerate}
\item Seguridad \begin{enumerate}
\item Las contraseñas de los usuarios deben estar encriptadas en algun tipo de hash.
\item Los usuarios deben tener su clave privada para contactar con el servidor
\end{enumerate}
\item IA \begin{enumerate}
\item Tener un bot construido
\end{enumerate}
\item Data Mining \begin{enumerate}
\item
\end{enumerate}
\item Miscelánea \begin{enumerate}
\item 
\end{enumerate}

\end{itemize}

\subsection{10 de diciembre	E4. Fase II del proyecto}
\subsection{13 de diciembre	E5. Informe de desarrollo}

\section{DIVISION DEL TRABAJO}

La division del trabajo entre los grupos se hara de la siguiente forma:

\begin{center}
\begin{tabular}{|c|c|}
    \hline Grupo 1 & Grupo 2 \\
    \hline Implementacion Desktop & Implementacion Server \\
    Implementacion Android & IA \\
    Proteccion & Data Mining \\
    Database 2 & Database 1 \\
    \hline
\end{tabular}
\end{center}\smallskip

Los miembros de los grupos seran los siguientes:

\begin{center}
\begin{tabular}{|c|c|}
    \hline
    Grupo 1  & Grupo 2 \\
    \hline
    Aritz & Erik \\
    Leire & Lander \\
    Gorka & Amaia \\
    \hline
\end{tabular}
\end{center}




\section{Server}

\subsection{Funcionalidades}

La lista de funciones del servidor será la siguiente:
\begin{enumerate}
\item Menu para cambiar los ajustes del servidor
\item Menu para ver el historial global de transacciones
\item Menu de acceso a la base de datos
\item Menu para crear/editar/eliminar usuarios
\item Ajustes de los bots 
\item Menu de acceso a las opciones de IA
\item Menu de acceso a las opciones de Seguridad
\end{enumerate}



\section{Forma de Implementación}




Los usuarios dentro del servidor deberían tener categorias de forma que un cliente no tenga acceso a el control de ciertos registros de la base de datos por ejemplo. Las categorias que se proponen son las siguientes:
\begin{center}
\begin{tabular}{|c|c|p{9cm}|}
\hline Nombre & Permisos & Descripcion \\
\hline Administrador & 0 & El administrador central de la aplicación tendría acceso a todos los comandos del server. \\
Programador & 1 & Los programadores tienen acceso a los comandos de edicion en el servidor, así como a algunas meta-funcionalidades. Pueden asignar más permisos (hasta el de programador) a otros usuarios.\\
Moderadores (?) & & \\
Cliente & 4 & Los clientes deberían tener la capacidad de acceder a las acciones sobre el servidor que impliquen su informacion directa o informacion global publica. Asi mismo deben tener la capacidad de modificar cierta informacion suya. \\
Invitados && \\ \hline

\end{tabular}
\end{center}

\subsection{Seguridad durante la transmision de los paquetes}

Para asegurar la seguridad de los paquetes hemos establecido que se encontrarán encriptados por una key que tendrán tanto el servidor como el usuario. Para enviar esta key el servidor y el cliente se comunicaran de forma segura entre ellos. 

Una persona que se registre por primera vez en el servidor(o se loguee) pasaría por el siguiente proceso:

\begin{enumerate}
\item El cliente crea un paquete con el usuario y contraseña, así como alguna información extra más. \item Este paquete es encriptado por una key aleatoria de longitud aleatoria dentro de su dominio. 
\item El cliente envia el paquete y el servidor lo recibe. El servidor encripta el paquete con una key aleatoria(la cual guarda de forma temporal) y lo envia de vuelta al cliente.
\item El cliente desencripta con su key el paquete, haciendo que su información de usuario solo esté encriptada ahora por la clave del servidor.
\item El cliente envia el paquete al servidor. Este lo desencripta con la clave que tenía guardada.
\end{enumerate}

Durante todo el proceso el paquete se ha enviado encriptado, manteniendo así la seguridad y evitando posibles ataques de Man in the Middle. Por otro lado, este método requiere que la función de encriptación (o las funciones) formen un grupo conmutativo sobre la composición.

Una vez se ha verificado la validez de las credenciales, el servidor usaría el mismo proceso para enviarle a el usuario el hash que usarán como key para encriptar paquetes a partir de ahora.


\section{Implementacion de Desktop}


\subsection{Funcionalidades}

La lista de funciones del cliente será la siguiente:
\begin{enumerate}
\item Ventana de logueo inicial
\item Menu con las siguientes opciones:\begin{itemize}
\item Envio de transaccion
\item Grupos o pagos compartidos
\item Configuración de la cuenta
\item Información sobre los gastos y el estado de la cuenta
\end{itemize}
\end{enumerate}



\section{Forma de Implementación}

La aplicacion de escritorio sera puramente una aplicacion que sirva como cliente para el servidor y que sirva para enviar sockets y representar de forma visual todos los comandos que se podran enviar al servidor.

La implementacion del software de Desktop se basará en tres valores principales: comodidad, sencilles y completitud. Buscamos crear una aplicacion que satisfaga todas las necesidades de los usuarios, manteniendo a su vez la sencillez que supone un software minimalista y con el apoyo de IA.




\section{Implementacion de Android}

\subsection{Funcionalidades}

La lista de funciones del cliente será la siguiente:
\begin{enumerate}
\item Ventana de logueo inicial
\item Menu con las siguientes opciones:\begin{itemize}
\item Envio de transaccion
\item Grupos o pagos compartidos
\item Configuración de la cuenta
\item Información sobre los gastos y el estado de la cuenta
\end{itemize}
\end{enumerate}


\section{IA y Data Analysis}

El apartado de IA de DeusZum se basara puramente en el analisis de la conducta de los usuarios dentro de la aplicacion con el unico fin de garantizar su seguridad.

Obligatorios

\begin{enumerate}
\item Comprobacion de movimientos/comportamientos sospechosos para evitar suplantaciones de identidad
\item Creacion de bots para el mantenimiento del servidor(Limpieza de datos basura, envio de emails, eliminación de cuentas inactivas)
\item Clustering del tipo de cliente
\item IA para envio de promociones segun las caracteristicas del cliente
\end{enumerate}

Opcionales

\begin{itemize}
    \item Analisis de los movimientos economicos de los clientes.
    \item Analisis del tracking de las direcciones de las transacciones de los clientes.
    \item Analisis conductual del cliente dentro de la apliacion.
    \item Prediccion de los clientes dentro de la aplicacion.
\end{itemize}


\subsection{Analisis de los movimientos}

\subsection{Bots de Automatización sobre el servidor}

Para tener en control el conjunto del servidor será necesario automatizar grandes partes del proceso, entre ellas, todos los temas que tengan que ver con analizar las posibles cuentas falsas, inactivas, errores de seguridad sobre las bases de datos, etc. Para ello necesitaremos programar un conjunto de bots los cuales actuaran segun arboles de decision o mediante funciones optimizadas previamente.


\section{Clustering de los clientes}

Una utilidad que queremos que nuestro servidor tenga es la capacidad de analizar a los clientes y dividirlos en categorias similares. Esto nos seria util a la hora de plantear posibles promociones y a que clientes les pueden interesar. De esta forma, no saturariamos con spam a todos los clientes sino que escogeriamos los correos a enviar. 

Para el clustering podriamos usar K nearest neighbour o algun tipo de sistema automatico que organice de forma autonoma todos los elemntos a base de analizar su informacion.

\section{Analisis de las Promociones}

Otra opcion importante es el analisis del mercado que tenemos. Cuanto tiempo pasan los clientes en nuestra app etc..


\section{SEGURIDAD}

Obligatorios

\begin{itemize}
    \item Encriptacion de todas las conexiones.
    \item Capacidad de trackeo del historial de conexiones.
    \item Nuevo algoritmo de encriptación inyectivo o conmutativo
    \item Proteccion de las cadenas de SQL del servidor para evitar inyecciones de SQL
    \item ‌Preparar funciones para eliminar/echar personas suplantando identidad etc. (Protocolo eliminar gente)
    
\end{itemize}

\subsection{Encriptacion del protocolo de envio de hash y verificacion de usuario}

Propiedades de esta encriptacion:
\begin{enumerate}
\item Ha de ser conmnutativa bajo composición.
\item Ha de ser inyectiva.
\item No puede ser roto por analisis de frecuencia.
\end{enumerate}

\subsection{Encriptacion de los codigos de los sockets}

A la hora de enviar la informacion al servidor, nos parece importante que no pueda exitir un sniffer que robe la informacion de nuestros clientes como puede ser el hash de la sesion o como puede ser el usuario y contrasenia. Para evitar esto, necesitaremos que nuestra informacion se envia encriptada con algun tipo de codigo decriptable asi como con un conjunto de informacion basura para evitar que a base de fuerza bruta en codigos cortos se pueda adivinar lo que ciertos codigos encriptados hagan.

Para solucionar este problema, el grupo de seguridad se encargara de estudiar el funcionamiento de ciertos tipos de encriptacion inyectiva o biyectiva y analizaran algunos metodos para aumentar la seguridad del algoritmo de encriptacion que deberan crear.

Sea $A$ el alfabeto, $f : A^n \to A^w$ la funcion de encriptacion con $n \in \mathbb{N}$.Las condiciones que establecemos ahora sobre el algoritmo de enriptacion seran las siguientes:

\begin{enumerate}
    \item $f$ sera inyectiva.
    \item $\mathbb{P}\left(|f(x)|=|x|\right) \to 0$ cuando $n \to \infty$.\, siendo $x \in A^n$.
    \item $f$ no pueda ser roto por analisis de frecuencia.
\end{enumerate}

\subsection{Trackero de los pagos}

\section{DATABASES}


Las tareas dentro de este subapartado se dividiran en 2, la de creacion y organizacion inicial de las bases de datos y la segunda, la de optimizacion de las bases de datos y su respectivo ajuste de seguridad con el fin de evitar ciertos tipos de ataque como las SQL Inyection o las code execution.


\begin{itemize}
    \item Optimizacion de las bases de datos
\end{itemize}





\section{CONCLUSIÓN}


\section{LIBRERIAS}

\begin{enumerate}
    \item \textbf{DeepLearning4J}: Usaremos esta libreria para la implementacion de redes neuronales y ejecutarla. A su vez, esta libreria permite el uso de tensores para la representacion de datos, lo cual nos puede ser util.
\end{enumerate}

\section{LIBROS}

\subsection{Java}

\subsection{Android}

\subsection{Server}

\subsection{IA}

\subsection{Data Analisys}

\subsection{Seguridad}


\begin{enumerate}
    \item 
\end{enumerate}

\begin{thebibliography}{9}
\bibitem{Example}
Autor1, Autor2. (2002) \textit{Nombre del articulo}, Lugar de publicación

\end{thebibliography}

\end{document}