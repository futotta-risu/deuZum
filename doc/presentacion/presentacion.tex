
\documentclass{article}

\usepackage[utf8]{inputenc}

%Librerias Matematicas
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage[table]{xcolor}% http://ctan.org/pkg/xcolor
%Algorithms
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}


\usepackage{soul}%To highligh
\usepackage{fancyhdr}
\usepackage[a4paper]{geometry}
\usepackage{parskip}
\usepackage{changepage}
\usepackage{lipsum}
\usepackage{tikz}
\usepackage{tikzpagenodes}

\usepackage{graphicx}
\usepackage{wrapfig}

\usepackage{adjustbox}
\usepackage{multirow}


\newcommand{\tabitem}{~~\llap{\textbullet}~~}

\pagestyle{plain}

%Paper Margins and size
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=30mm,
 top=20mm,
 right=30mm,
 bottom=20mm
 }

%Page Numeration
\pagestyle{plain}
\thispagestyle{empty}
\clearpage\pagestyle{plain}

%Interline 1.5 (of Word)
\linespread{1.25}

%Ident between 0.5 - 1.25max
\setlength{\parindent}{15pt}

%Math Theorem style
\newtheorem{theorem}{Teorema}
\newtheorem{corollary}{Corolario}[theorem]
\newtheorem{lemma}{Lemma}
\newtheorem*{remark}{Nota}
\theoremstyle{definition}
\newtheorem{definition}{Definición}[section]
\newenvironment{Proof}[1][Proof]
  {\proof[#1]\leftskip=1cm}
  {\endproof}

%Algorithm and PseudoCode
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother 


\begin{document}

\begin{titlepage}
	\begin{center}
	    \includegraphics[scale = 0.5]{LogoIngenieriaR.jpg}\\[1.0 cm]
	\end{center}
	
    \vspace*{150pt}
    \centering
    {\Huge
     \textbf{DEUSZUM}
    }
    
	\vspace*{200pt}
	
	
	\begin{minipage}{2in}
		\begin{tabular}{l}
			Terres Escudero, Erik B.    \\
			Zarate Jayo, Gorka   \\
			Zugazaga Alonso, Aritz  \\
			Acha Aristegui, Amaia  \\
			Gago López,Leire  \\
			San Millan Langa, Lander 
		\end{tabular}
	\end{minipage}
	\hfill
	\begin{minipage}{3in}
	\begin{flushright}
	\Large Curso 2019/2020 \\
		\Huge Ing. Informatica\\
		\LARGE Programacion III
	\end{flushright}
		
	\end{minipage}


    
	
\end{titlepage}

\tableofcontents

\clearpage

\section{INTRODUCCIÓN}

DeusZum es una aplicación de gestión de dinero online para la gestión de pagos, proyectos o costes grupales. DeusZum ofrece un sistema seguro de transferencias de forma que el cliente no tenga que preocuparse de que este pasando con su dinero en todo momento.

DeusZum estará implementado en un servidor y daría servicio a los usuarios a través de un programa en Windows y una aplicación en Android. Cada una de ellas implementada para conectarse a un servidor central, en el cual se almacenarán los datos, procesarán las peticiones y se garantizará la seguridad de la información.

El servicio que ofrece DeusZum está dividido en diferentes sectores, algunos puramente económicos y otros de análisis de la conducta o de las transacciones. El servidor ejecutara todas las peticiones de los usuarios y devolverá la información que se haya solicitado. Toda la información mientras se enviá se encontrara encriptada para la seguridad del usuario.

\section{FORMA DE TRABAJO}


\subsection{Division del trabajo}

Para la realización del proyecto, hemos optado por la división del trabajo en grupos con temáticas separadas. Los dos grupos tendrán que trabajar en una categoría central entre IA y Seguridad, y, trabajar en una parte de la implementación y algoritmia. Las categorías y subcategorías serian las siguientes:

\begin{center}
\begin{tabular}{|c|c|c|}
	\hline	
	\cellcolor{cyan!12} Implementacion & \cellcolor{cyan!12}Uso de datos & \cellcolor{cyan!12}Seguridad \\ \hline
	Servidor & Data Analysis & Database \\
	Windows & IA & Criptografia \\
	Android & Big Data & Proteccion \\
	\hline
	
\end{tabular}
\end{center}



Cada uno de los grupos tendra un conjunto de tareas las cuales se diviran en \textit{tareas principales} y \textit{tareas secundarias}. Las tareas principales son aquellas a las que se les daran prioridad y buscamos que esten terminadas a la hora de terminar el proyecto. Las tareas secundarias son aquellas que no tienen tanta importancia y que se empezaran una vez se vallan acabando las tareas principales.

A su vez, las tareas estaran numeradas segun importancia, dificultad y tiempo de trabajo con el fin de poder establecer un orden de prioridad para que su progreso haga que el proceso de construccion del proyecto sea relativamente optimo y de forma que su estructura no se vea afectada por software anterior.

Por ultimo, hay un sector no especializado que trata los temas de algoritmia sobre como handlear la forma de minimizar el total de pagos que hay realizar en forma de peticiones. Este algoritmo estara pensado en forma de algoritmo greedy al tener complejidad $O(n)$, pero en caso de que consigamos un algoritmo que no dependa de combinatorial algorithms o complejidades exponenciales para encontrar el minimo numero de pagos, tal vez aniadamos la opcion. Por ahora no sabemos como de rentable resultaria este algoritmo, ni tampoco sabemos ninguna upperbound del numero de movmientos que sea inferior a $n$ aproximadamente. Esto se mostrara en la bibliografia final o en la documentacion sobre el software.

El apartado de algoritmia se dividira segun convenga, aunque se mostrara dentro de la documentacion quien ha hecho que tareas y como ha resuelto los problemas.
\subsection{Error Handling}

Para evitar errores que afecten al codigo a nivel global, hemos optado por utilizar github y hacer que cada miembro del grupo tenga su propia cuenta. Los errores, comentarios y todo se enviarian a traves de github excepto la informacion mas urgente que se enviaria a traves de un grupo de whatsapp o telegram/discord en si defecto.

\subsection{Preparacion del temario}

Para la preparacion del temario que queremos trabajar en el trabajo hemos optado por utilizar un conjunto de libros que consideramos basicos para las personas que no tienen mucha experiencia y utiles/importantes para las personas que tengan un cierto control en ciertos aspectos. Esta lista de libros se encontrara en el apendice de este documento categorizada.

\section{PLANIFICACION}

\subsection{8 de octubre	E1. Propuesta de proyecto y planificación }

\begin{tabular}{|p{3cm}|p{11cm}|}
\hline
\multirow{2}{*}{Server} & \tabitem Conseguir conectar un servidor SQL a el servidor.\\
& \tabitem Hacer que el servidor lea archivos properties.\\
\hline
\multirow{2}{*}{Desktop} & \tabitem Crear la ventana junto con sus componentes.\\
& \tabitem Crear el metodo para enviar sockets. \\
\hline  
 Android & \tabitem Leer un poco sobre Android \\
\hline 
 Database & \tabitem  Crear la estructura de la base de datos. \\
 \hline 
 \multirow{2}{*}{Seguridad} & \tabitem Haber leido un mínimo sobre RSA, Blowfish, MD5, SHA512, Cesar... \\
 & \tabitem Plantear los métodos de encriptación que se usarán para cada tarea dentro del servidor.\\
 \hline 
 \multirow{2}{*}{IA} & \tabitem Plantear que metodos usaremos en el proceso \\
 &  \tabitem Plantear que tipo de bots queremos usar\\
 \hline 
 \multirow{4}{*}{Miscelanea} & \tabitem  Entender como funciona la documentación del proyecto. \\
 & \tabitem Entender como funciona el sistema de comandos del servidor. \\
 & \tabitem Organizar el repositorio.\\
 & \tabitem Estudiar la posibilidad de cambiar la documentación a una wiki.\\
\hline
\end{tabular}



\subsection{29 de octubre	E2. Fase I del proyecto}

\begin{tabular}{|p{3cm}|p{11cm}|}
\hline
\multirow{2}{*}{Server} & \tabitem Estructurar bien el servidor.\\
& \tabitem Todos los mensajes de los sockets deberán ir encriptados.\\
\hline
\multirow{2}{*}{Desktop} & \tabitem Cliente funcional para enviar sockers\\
& \tabitem Cliente visualmente no horrible \\
\hline  
 \multirow{2}{*}{Android} & \tabitem Cliente funcional para enviar sockers \\
 & Cliente visualmente no horrible \\
\hline 
 Database & \tabitem  La base de datos debe estar creada y con algunos datos de ejemplo \\
 \hline 
 \multirow{2}{*}{Seguridad} & \tabitem Las contraseñas de los usuarios deben estar encriptadas en algun tipo de hash. \\
 & \tabitem Los usuarios deben tener su clave privada para contactar con el servidor\\
 \hline 
 \multirow{2}{*}{IA} & \tabitem Tener un bot construido \\
 &  \tabitem \\
 \hline 
 \multirow{4}{*}{Miscelanea} & \tabitem  . \\
 & \tabitem . \\
 & \tabitem .\\
 & \tabitem .\\
\hline
\end{tabular}


\end{itemize}

\subsection{10 de diciembre	E4. Fase II del proyecto}
\subsection{13 de diciembre	E5. Informe de desarrollo}

\section{DIVISION DEL TRABAJO}

La division del trabajo entre los grupos se hara de la siguiente forma:

\begin{center}
\begin{tabular}{|c|c|}
    \hline Grupo 1 & Grupo 2 \\
    \hline Implementacion Desktop & Implementacion Server \\
    Implementacion Android & IA \\
    Proteccion & Data Mining \\
    Database 2 & Database 1 \\
    \hline
\end{tabular}
\end{center}\smallskip

Los miembros de los grupos seran los siguientes:

\begin{center}
\begin{tabular}{|c|c|}
    \hline
    Grupo 1  & Grupo 2 \\
    \hline
    Aritz & Erik \\
    Leire & Lander \\
    Gorka & Amaia \\
    \hline
\end{tabular}
\end{center}




\section{Implementacion de Server}


La implementacion del Server sera una implementacion sencilla de un serversocket con la capacidad de extension de funcionalidades. Incluso tal vez no necesitar modificar el codigo del server per se para la ampliacion de su funcionalidad. 

Los sockets del servidor tendrian una estructura tal que:
\begin{enumerate}
    \item Conseguir acceder a la cuenta de un usuario.
    \item Comprobar que el usurio existe y verificar que la contrasenia es correcta.
    \item Verificar que no ha habido un abnormal comportation.
    \item Devolverle un hash que representa su sesion actual en el servidor.
    \item En caso de que quiera guardar la sesion, devolverle otro hash que represente su sesion y guardar en el servidor que esa sera su sesion activa.
    \item Este hash debera ser modificado cada x tiempo.
\end{enumerate}

\begin{wrapfigure}{R}{0.4\textwidth}
\centering
\includegraphics[width=0.4\textwidth]{pics/serverclient.png}
\caption{Modelo del Servicio.}
\end{wrapfigure} 

Los sockets de funcionalidad estaran compuestos por un comando, luego el servidor devolvera un codigo hash de sesion activa y a continuacion el cliente enviara toda la informacion con el hash como cabecera.

Estos hash se enviaran a traves de la web mediante un sistema de criptografia implementado por nuestro equipo y, por otro lado, plantearemos un metodo mas seguro para mostrar la capacidad de implementar metodologias mas serias o profesionales.

El ServerHandler no debera ser modificado cada vez que se aniada un nuevo codigo de funcionalidad en el server. Para manejar esto, hemos pensado en hacer que el serverhandler funcione mediante un arbol Autobalanceado (AVL o Black Red por ejemplo) que se genera al inicio de la sesion del servidor y que despues, en cada peticion, el serverhandler simplemente busque cual de las hojas es y luego ejecute otra funcon que se encuentre en algun otro lado del codigo. Este arbol se generaria mediante una base de datos que contenga el conjunto de funcionalidades y la funcion asociada.


Los usuarios dentro del servidor deberían tener categorias de forma que un cliente no tenga acceso a el control de ciertos registros de la base de datos por ejemplo. Las categorias que se proponen son las siguientes:
\begin{center}
\begin{tabular}{|c|c|p{9cm}|}
\hline Nombre & Permisos & Descripcion \\
\hline Administrador & 0 & El administrador central de la aplicación tendría acceso a todos los comandos del server. \\
Programador & 1 & Los programadores tienen acceso a los comandos de edicion en el servidor, así como a algunas meta-funcionalidades. Pueden asignar más permisos (hasta el de programador) a otros usuarios.\\
Moderadores (?) & & \\
Cliente & 4 & Los clientes deberían tener la capacidad de acceder a las acciones sobre el servidor que impliquen su informacion directa o informacion global publica. Asi mismo deben tener la capacidad de modificar cierta informacion suya. \\
Invitados && \\ \hline

\end{tabular}
\end{center}

\subsection{Seguridad durante la transmision de los paquetes}

Para asegurar la seguridad de los paquetes hemos establecido que se encontrarán encriptados por una key que tendrán tanto el servidor como el usuario. Para enviar esta key el servidor y el cliente se comunicaran de forma segura entre ellos. 

Una persona que se registre por primera vez en el servidor(o se loguee) pasaría por el siguiente proceso:

\begin{enumerate}
\item El cliente crea un paquete con el usuario y contraseña, así como alguna información extra más. \item Este paquete es encriptado por una key aleatoria de longitud aleatoria dentro de su dominio. 
\item El cliente envia el paquete y el servidor lo recibe. El servidor encripta el paquete con una key aleatoria(la cual guarda de forma temporal) y lo envia de vuelta al cliente.
\item El cliente desencripta con su key el paquete, haciendo que su información de usuario solo esté encriptada ahora por la clave del servidor.
\item El cliente envia el paquete al servidor. Este lo desencripta con la clave que tenía guardada.
\end{enumerate}

Durante todo el proceso el paquete se ha enviado encriptado, manteniendo así la seguridad y evitando posibles ataques de Man in the Middle. Por otro lado, este método requiere que la función de encriptación (o las funciones) formen un grupo conmutativo sobre la composición.

Una vez se ha verificado la validez de las credenciales, el servidor usaría el mismo proceso para enviarle a el usuario el hash que usarán como key para encriptar paquetes a partir de ahora.


\section{Implementacion de Desktop}

La aplicacion de escritorio sera puramente una aplicacion que sirva como cliente para el servidor y que sirva para enviar sockets y representar de forma visual todos los comandos que se podran enviar al servidor.

La implementacion del software de Desktop se basará en tres valores principales: comodidad, sencilles y completitud. Buscamos crear una aplicacion que satisfaga todas las necesidades de los usuarios, manteniendo a su vez la sencillez que supone un software minimalista y con el apoyo de IA.




\section{Implementacion de Android}




\section{IA}

El apartado de IA de DeusZum se basara puramente en el analisis de la conducta de los usuarios dentro de la aplicacion con el unico fin de garantizar su seguridad.

Las tareas que queremos hacer en el apartado de IA son las siguientes:

\begin{itemize}
    \item Analisis de los movimientos economicos de los clientes.
    \item Analisis del tracking de las direcciones de las transacciones de los clientes.
    \item Analisis conductual del cliente dentro de la apliacion.
    \item Prediccion de los clientes dentro de la aplicacion.
\end{itemize}


\subsection{Analisis de los movimientos}

\subsection{Bots de Automatización sobre el servidor}

Para tener en control el conjunto del servidor será necesario automatizar grandes partes del proceso, entre ellas, todos los temas que tengan que ver con analizar las posibles cuentas falsas, inactivas, errores de seguridad sobre las bases de datos, etc. Para ello necesitaremos programar un conjunto de bots los cuales actuaran segun arboles de decision o mediante funciones optimizadas previamente.

\section{DATA ANALYSIS}

\begin{itemize}
    \item Clustering
    \item Analisis de mercado
\end{itemize}

\section{Clustering de los clientes}

Una utilidad que queremos que nuestro servidor tenga es la capacidad de analizar a los clientes y dividirlos en categorias similares. Esto nos seria util a la hora de plantear posibles promociones y a que clientes les pueden interesar. De esta forma, no saturariamos con spam a todos los clientes sino que escogeriamos los correos a enviar. 

Para el clustering podriamos usar K nearest neighbour o algun tipo de sistema automatico que organice de forma autonoma todos los elemntos a base de analizar su informacion.

\section{Analisis de las Promociones}

Otra opcion importante es el analisis del mercado que tenemos. Cuanto tiempo pasan los clientes en nuestra app etc..

\section{SEGURIDAD}

\begin{itemize}
    \item Encriptacion de todas las conexiones.
    \item Capacidad de trackeo del historial de conexiones
\end{itemize}

\subsection{Encriptacion del protocolo de envio de hash y verificacion de usuario}

Propiedades de esta encriptacion:
\begin{enumerate}
\item Ha de ser conmnutativa bajo composición.
\item Ha de ser inyectiva.
\item No puede ser roto por analisis de frecuencia.
\end{enumerate}

\subsection{Encriptacion de los codigos de los sockets}

A la hora de enviar la informacion al servidor, nos parece importante que no pueda exitir un sniffer que robe la informacion de nuestros clientes como puede ser el hash de la sesion o como puede ser el usuario y contrasenia. Para evitar esto, necesitaremos que nuestra informacion se envia encriptada con algun tipo de codigo decriptable asi como con un conjunto de informacion basura para evitar que a base de fuerza bruta en codigos cortos se pueda adivinar lo que ciertos codigos encriptados hagan.

Para solucionar este problema, el grupo de seguridad se encargara de estudiar el funcionamiento de ciertos tipos de encriptacion inyectiva o biyectiva y analizaran algunos metodos para aumentar la seguridad del algoritmo de encriptacion que deberan crear.

Sea $A$ el alfabeto, $f : A^n \to A^w$ la funcion de encriptacion con $n \in \mathbb{N}$.Las condiciones que establecemos ahora sobre el algoritmo de enriptacion seran las siguientes:

\begin{enumerate}
    \item $f$ sera inyectiva.
    \item $\mathbb{P}\left(|f(x)|=|x|\right) \to 0$ cuando $n \to \infty$.\, siendo $x \in A^n$.
    \item $f$ no pueda ser roto por analisis de frecuencia.
\end{enumerate}

\subsection{Trackero de los pagos}

\section{DATABASES}


Las tareas dentro de este subapartado se dividiran en 2, la de creacion y organizacion inicial de las bases de datos y la segunda, la de optimizacion de las bases de datos y su respectivo ajuste de seguridad con el fin de evitar ciertos tipos de ataque como las SQL Inyection o las code execution.


\begin{itemize}
    \item Optimizacion de las bases de datos
\end{itemize}





\section{CONCLUSIÓN}


\section{LIBRERIAS}

\begin{enumerate}
    \item \textbf{DeepLearning4J}: Usaremos esta libreria para la implementacion de redes neuronales y ejecutarla. A su vez, esta libreria permite el uso de tensores para la representacion de datos, lo cual nos puede ser util.
\end{enumerate}

\section{LIBROS}

\subsection{Java}

\subsection{Android}

\subsection{Server}

\subsection{IA}

\subsection{Data Analisys}

\subsection{Seguridad}


\begin{enumerate}
    \item 
\end{enumerate}

\begin{thebibliography}{9}
\bibitem{Example}
Autor1, Autor2. (2002) \textit{Nombre del articulo}, Lugar de publicación

\end{thebibliography}

\end{document}